utána lehet kinyitni. Ez mind-mind szépen leolvasható az ábráról. Ezt leprogramozni könnyű, nem kell azon rágódni, mit is szeretne a megrendelő. Egy állapot átmenetre írhatunk kiváltó eseményt (angolul: trigger), index zárójelben OCL feltételt, amit őrfeltételnek (angolul: guard) szoktunk hívni, és per (/) jel után pedig programkódot írhatunk, például, hogy egy mező hogyan változik. Ez utóbbi szoktuk hatásnak (angolul: effect) is hívni. Nézzünk egy egyszerű példát, a 2 bites számlálót: PlantUML szkript: @startuml [*] -right-> Zéró : létrehoz / számláló = 0 Zéró --> NemZéró : pluszEgy / számláló++ NemZéró --> NemZéró : pluszEgy [számláló<3] / számláló++ NemZéró --> Zéró : pluszEgy [számláló=3] / számláló = 0 @enduml Ez nem a 2 bites számláló szokásos ábrázolása. A szokásos leírásban 4 állapot van: 00 -> 01 -> 10 -> 11 -> 00, ugyanakkor ebben a példában nincs lehetőség bemutatni az állapot átmenetre írható „kiváltó esemény [őrfeltétel] / hatás” hármast. Ezért a fenti példában csak két állapot van: Zéró és NemZéró. A 2 bites számláló értékét a számláló mezőben tároljuk. A kiváltó esemény a pluszEgy. A NemZéró állapotból pluszEgy hatására vagy maradunk a NemZéró állapotban, ha még nem értük el számlálóval a 3-mat, ha már elértük, akkor visszakerülünk a Zéró állapotba, hiszen 2 biten maximum 3-ig tudunk számolni. Fontos megjegyezni, hogy a fenti hármasból bármelyik elhagyható. Erre nézzük meg a PIN kód példát, ami egyben példa az elágazásra is: PlantUML szkript: @startuml state elágazás <<choice>> state "PIN megadása" as PIN PIN: /Ki: Adja meg PIN kódját! [*] -right-> PIN : bekapcsolás PIN -right-> elágazás : /ellenőrizPIN elágazás -left-> PIN : [PIN rossz] elágazás -right-> [*] : [PIN jó] @enduml ITT járok @startuml state elágazás <<choice>> state elágazás2 <<choice>> state "PIN megadása" as PIN PIN: /Ki: Adja meg PIN kódját! [*] -right-> PIN : bekapcsolás / counter = 0 PIN -right-> elágazás : /ellenőrizPIN elágazás -left-> elágazás2 : [PIN rossz] / counter++ elágazás2 --> PIN : [counter<3] elágazás2 --> [*] : [counter==3] elágazás -right-> [*] : [PIN jó] @enduml Itt lázhatunk olyan állapotátmenetet, ahol csak a kiváltó eseményt adtuk meg (bekapcsolás), olyat, ahol csak OCL őrfeltételt ([PIN rossz], illetve [PIN jó]), és olyat is, ahol csak hatást (/ellenőrizPIN). Illetve látunk egy olyat is, hogy „/Ki: Adja meg PIN kódját!”. Ez a következő szint, amikor az állapoton belül tevékenységeket (angolul: state action) adunk meg. Ez lehet egy egyszerű üzenet a felhasználónak, de akár programkód is kerülhet ide. Ennek akkor van jelentősége, ha több ugyanoda mutató állapot átmenetnek is ugyanaz a hatása, vagy a kimenő éleknek ugyanaz a hatása, de bármi mást is kifejezhetünk. A szokásos szintaxis ugyanaz, mint az állapot átmenet esetén: <kiváltó esemény> <[OCL őrfeltétel]> / hatás. E hármasból a hatást mindenképp meg kell adni, ami általában valamilyen pszeudokód. Ha egyértelmű, hogy hatásról van szó, akkor a per (/) jel elhagyható. Ha nem írunk semmit, csak a hatást, akkor ezt úgy értjük, hogy ez a hatás, ha belépünk az állapotba. Nézzünk példát állapoton belül tevékenységre: PlantUML kód: @startuml Autó: létrehozás esetén /Autó.számláló++ Autó: megszünés esetén /Autó.számláló-- [*] -right-> Autó : létrehozás new-val [*] -right-> Autó : létrehozás gyárral Autó -right-> [*] : megszünés totálkár miatt Autó -right-> [*] : megszünés autóbontóban @enduml Hogyan kapcsolódik a DIP és az állapotgép? Könnyen belátható, hogy az állapotgép inkább az üzleti logikához kapcsolódik, feltéve, hogy elég magas szinten írja le a rendszer működését, sok részletet nyitva hagy, az alsóbb rétegek kidolgozhassák ezeket a részleteket. Ha ez így van, akkor a DIP szerint az állapotgép az absztrakció része. Egy olyan szerződés, amit állapotokkal fogalmazunk meg. Ahhoz, hogy ezt ábrázolni tudjuk, ahhoz az osztály diagramot kell vegyítenünk állapotgép diagrammal. Ez többféleképp is megoldható. Az egyik legegyszerűbb, ha az állapotgépet betesszük egy megjegyzésbe, és a megjegyzés az absztrakcióra mutat. Nézzünk erre egy példát: PlantUML kód: @startuml allow_mixing class Sofőr {} interface KormányMű { +{abstract} void gyújtástAd() +{abstract} void gyújtástLevesz() } class Autó {} note as ÁllapotGép {{ state Elágazás <<choice>> [*] -up-> Tétlen : létrehozás Tétlen --> Indítás : / gyújtástAd() Indítás --> Elágazás Elágazás --> Működőképes : [alrendszerek OK] Elágazás --> NemMűködőképes : [alrendszerek HIBA] Működőképes --> Tétlen : / gyújtástLevesz() NemMűködőképes --> Tétlen : / gyújtástLevesz() }} end note ÁllapotGép -- KormányMű Sofőr o-right-> KormányMű Autó .left.|> KormányMű @enduml A másik lehetőség, hogy közvetlenül az absztrakt osztályon vagy interfészen belül adjuk meg az állapotgépet. Még ezt is támogatja a PlantUML úgy hogy az állapotgépet {{ }} jelek közé írjuk, mint az előző példában a megjegyzésen belül. Még jobban kombinálhatjuk a különböző diagramokat, ha PlantUML-ben kiadjuk az allow_mixing parancsot. Sajnos ez elég csúnya végeredményt ad. Jobb a harmadik megoldás, amikor csak jelzem, hogy ehhez az absztrakcióhoz van egy állapotgép, és azt egy másik ábrán adom meg. Erre is nézzünk egy példát. Ebben a példában egyszerű invariánsként adom meg, hogy van állapotgép, amit be kell tartani: PlantUML kód: @startuml allow_mixing package DIP { class Sofőr {} interface KormányMű { **inv:** KormányMű-ÁllapotGép -- +{abstract} void gyújtástAd() +{abstract} void gyújtástLevesz() } class Autó {} Sofőr o-down-> KormányMű Autó .up.|> KormányMű } package KormányMű-ÁllapotGép { state Init state Tétlen state Indítás state Elágazás <<choice>> state Működőképes state NemMűködőképes Init --> Tétlen : létrehozás Tétlen --> Indítás : / gyújtástAd() Indítás --> Elágazás Elágazás -up-> Működőképes : [alrendszerek OK] Elágazás -right-> NemMűködőképes : [alrendszerek HIBA] Működőképes --> Tétlen : / gyújtástLevesz() NemMűködőképes --> Tétlen : / gyújtástLevesz() } @enduml Ebben a példában már használni kellett az allow_mixing parancsot. Habár az előző példában is benne volt, ott kihagyható lett volna. Sajnos a kezdő állapot, ami PlantUML-ben a [*] karaktersorozat jelöl, mindig hibát okoz. Ezért ezt az Init állapottal váltottuk ki. Mint látható, a két példa lényegében ugyanaz. Talán még szebb lenne különálló diagramokat használni. Itt csak a jegyzet kedvéért tettük be a két diagramot egy ábrába. Minden tervező döntse el, hogy neki melyik megoldás a szimpatikusabb. A lényeg, az állapotgépet, mint a szerződés részét kell használni, invariánsként lehet felvenni az absztrakció megtervezésekor. 1.1.14. DIP vizsgálata Imperatív vs. Deklaratív szemszögből Az előző részekben a DIP és a szerződések kapcsolatát elemeztük. Azt láttuk, hogy a szerződés rögzíti, hogy MIT csinál a metódus, de nem rögzíti, hogy HOGYAN oldja meg ezt a feladatot. A HOGYAN kérdésre a metódus implementációja adja meg a választ, de azt majd csak az implementáló osztály adja meg. A MIT és HOGYAN szavakat azért kell kiemelni, mert egy nagyon fontos dologra tudunk a segítségükkel rávilágítani. Tudjuk, hogy a programozási nyelveknek 2 nagy családja van, az imperatív és a deklaratív programozási nyelvek. Minden programozási nyelven algoritmusokat írunk és egy algoritmusnak két kérdésre kell válaszolnia: MIT old meg? és HOGYAN oldja meg? Jól tudjuk, hogy az imperatív nyelvek a HOGYAN kérdésre teszik a hangsúlyt, a programozó lényegében szabad kezet kap, HOGYAN implementálja az adott feladatot. Azt szoktuk mondani, hogy az imperatív oldalon a programozó szabadon lehet hülye. Ez egyre kevésbé igaz, mert az igazán veszélyes, bonyolult, könnyen elrontható programozó eszközöket sorra csavarják ki a kezünkből. C-ben még volt pointer aritmetika, Javában már nincs. C-ben még a programozó feladata volt a dinamikus memóriából a szemét felszabadítása, Javában ezt már a GC végzi. Lassan ott tartunk, hogy már ciki ciklust írni. A menő C# programozók LINQ-t, a menő Java programozók stream-eket használnak és az ott elérhető függvénnyel paraméterezhető függvényeket, és már alig írnak ciklusokat. A másik oldalon, a deklaratív programozási nyelvek a MIT kérdésre teszik a hangsúlyt. Csak deklarálni kell a megoldandó problémát, azaz MIT kell megoldani, és a keretrendszer kitalálja, hogy hogyan, melyik algoritmus segítségével. Ez könnyűnek hangzik és tényleg, könnyebb is deklaratív oldalon programozni, tisztább, szárazabb érzés. Ugyanakkor ezen az oldalon is vannak gondok, nincs mellékhatás, ami első hallásra jó hír, de ha belegondolunk, a képernyőre írás is mellékhatás. Nincs ciklus, csak rekurzió, és absztrakció helyett magasabb rendű függvények vannak. Ráadásul, az imperatív nyelvek sokkal jobban elterjedtek. Tehát az imperatív nyelvek elterjedtebbek, de deklaratív módon könnyebb programozni, mindkét oldalnak van előnye és hátránya, ezért a két oldal közeledik egymáshoz. Például: deklaratív oldalon egyre több nyelvben jelenik meg az objektum és az osztály fogalma; imperatív oldalon használhatunk lambda kifejezést. A DIP elvet betartva egy újabb deklaratív elem jelenik meg az imperatív oldalon: Mivel az absztrakció a MIT kérdésre add választ, ezért rákényszerülünk, hogy a MIT kérdés hangsúlyosabb legyen az imperatív oldalon is. 1.2. Tervezési minták és a DIP A tervezési alapelvek magasabb absztrakciós szinten vannak, mint a tervezési minták. Ez azt jelenti, hogy a tervezési mintákban gyakran fülön csíphetünk egy-egy tervezési alapelvet. Először nézzük meg az egyes absztrakciós szinteket a nagyon elvonttól az igazán konkrét felé: - „A program kódja állandóan változik.”: Ez a fő alapelvünk, programozás technológiában minden más elvet ebből vezethetünk le. - Dolgok szétválasztásának elve: „Separation of Concerns”, „Amit szét lehet választani, azt érdemes szétválasztani”. - Kontrol megfordításának elve, Inversion of Control (IoC), ne a program várjon eseményre, az esemény hívja a programot. - OOP alapelvei, mint az öröklődés, az egységbezárás, a többalakúság és az absztrakció használata. - Tervezési alapelvek, ide tartoznak a SOLID elvek, a GOF1-2, de a Hollywood elv is. - Tervezési minták, ide tartoznak a GOF könyv mintái. - Osztálykönyvtárak (angolul: library), amit egy régi szóhasználat, napjainkban inkább a névtér, vagy a csomag név használata elterjedt egy-egy feladat megoldásának eszközkészlete. - Újrahasznosítható forráskód, amit mondjuk könnyen használhatunk Android-os, és mondjuk webes környezetben is. - Megrendelőre szabott specifikus forráskód, amely legvégül, a sok réteg legalján lefut. Persze ez a felsorolás csak a szerzők meggyőződését tükrözi. Más források más-más absztrakciós szinteket tartalmazhatnak, de abban elég nagy egyetértés van, hogy a tervezési alapelvek magasabb absztrakciós szinten állnak, mint a tervezési minták. Mindenki egyetért abban, hogy Megfigyelő tervezési mintában szépen tetten érhető a Hollywood tervezési alapelv, „ne hívj, majd mi hívunk”. Sok-sok hasonló példát hozhatnánk itt fel. Ebben a részben azt tárgyaljuk, hogy a DIP hogyan jelenik meg az egyes tervezési mintákban. Majd minden tervezési mintáról elmondható, hogy szétválaszt valamit valamitől. Mivel a DIP-nek is a feladata, ezért nagyon gyanús, hogy DIP több tervezési mintában is tetten érhető. Nézzük meg milyen kérdésekre kell feltennünk, ezen vizsgálat során? - Minden nyíl absztrakcióra mutat? Ha igen, akkor valószínűleg egy jó tervet látunk, ahol a tervező erőskezű, ugyanakkor a programozók nem tudnak nemet mondani a tervezői túlkapásokra (lásd a „Mikor ne használjuk a DIP tervezési alapelvet” részt). Mindenesetre az ilyen tervekben könnyen találhatunk DIP-et. Megjegyzés: Ha nem minden nyíl mutat absztrakcióra, attól még lehet a tervben DIP, sőt valahol egészségesebb is, ha erre nem a válasz, mert az mutatja, hogy a programozóknak is volt beleszólásuk a tervbe. - Van olyan absztrakció, amire HAS-A és IS-A kapcsolat is mutat? Ha igen, ez már majdnem biztos DIP. Ugyanakkor lehet, hogy ugyanaz az osztály mutat HAS-A és IS-A kapcsolattal az absztrakcióra. Ez az eset nem DIP, mivel a DIP lényege, hogy szétválassza a HAS-A és az IS-A oldalt. Ha ez a két oldal egy és ugyanaz, vagy erős egyéb kapcsolat van köztük, akkor ez nem DIP. - Van olyan absztrakció, amire HAS-A és IS-A kapcsolat is mutat, és ez a két oldal szétválik? Ha igen, akkor ez DIP! Ha a két oldal csak nagyából válik szét, azaz nem csak a HAS-A oldalról jön hívás az absztrakción keresztül az IS-A oldal felé, hanem visszafelé is, mondjuk egy callback-en keresztül, akkor ez vagy DIP vagy nem DIP. Ha a visszafelé kommunikáció több, mint valamilyen visszajelzés, akkor ez nem DIP. Ha visszafelé kommunikáció csak valamiféle visszajelzés, akkor ez DIP. Nyilván itt van értelmezési szabadság, hogy ki mit gondol „csak valamiféle visszajelzésnek”, de ez egy absztrakt alapelvnél teljesen természetes. Ebben a jegyzetben akkor mondjuk azt, hogy ez „csak valamiféle visszajelzés”, ha az IS-A oldalról egy egyszerű asszociáció mutat vissza a HAS-A oldalra. - Van olyan absztrakció, amire HAS-A és IS-A kapcsolat is mutat, és ez a két oldal szétválik, és a HAS-A oldal a kliens kód? Ha igen, akkor a legszigorúbb értelmezés szerint is ez egy DIP. Már csak az a kérdés, hogy mit jelent a kliens kód? A kliens kód alatt olyan kódot értünk, amiról nem tudunk semmit, csak azt, hogy használni akarja a tervezés alatt álló kódrészlet szolgáltatásait. Ebben a fejezetben megvizsgálunk két tervezési mintát, amiről tudván tudjuk, hogy a legfontosabb tulajdonságuk két dolog szétválasztása, ez a Híd és a Megfigyelő. Ezek után a GOF könyvben felsorolt tervezési mintákat vesszük szép sorba. 1.2.1. Szétválasztás a fókuszban: Híd és Megfigyelő Vizsgáljunk meg néhány jól ismert tervezési mintát, hogy megjelenik-e bennük a DIP, és ha igen, hogyan. Kezdjük azokkal, amikről jól tudjuk, hogy szétválasztanak valamit, hiszen mint láttuk a DIP-nek van köze a szétválasztáshoz. Két tervezési minta van a köztudatban, amik direkt szétválasztásra jók: ● Híd (angolul: Bridge): a híd tervezési minta a különböző lehetséges felületeket és a különböző lehetséges implementációkat választja szét. ● Megfigyelő (angolul: Observer): a megfigyelő tervezési minta szétválasztja a megfigyeltet és a megfigyelőket. 1.2.2. Híd Nézzük meg a Híd (angolul: Bridge) tervezési mintának az UML ábráját: PlantUML szkriptje: @startuml abstract class Felület { } abstract class Megvalósítás { } class FelületA {} class FelületB {}